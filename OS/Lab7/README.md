# Лабораторная работа 7: Таблица поиска строк в текстовом файле 2.
#### Задание:
Измените предыдущую программу так, чтобы использовалось отображение файла в память взамен использования read(2), lseek(2) и write(2).

#### Ход выполнения:

###### ReadFile:
Теперь вместо цикла, в котором просходит чтение файла через **read** в буфер, используется механизм отображения в память. С помощью ```int fstat(int fildes, struct stat *buf);``` мы получаем данные файла по дексриптору **filedes** и сохраняем их в структуру **fstat**. Структура **fstat** хранит много информации о файле, включая устройство, inode, режим доступа, общий размер в байтах, время последнего доступа, модификации, изменения и много всего ещё. Нас в данном случае интересует размер файла, то есть мы используем ```bufferSize = s.st_size;```, после этого переменная bufferSize будет хранить размер файла в байтах. На этом этапе у нас есть дескриптор и размер файла по этому дескриптору, можно вызывать системную функцию ```void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);``` для отображения файла в адресное пространство нашего процесса через механизм отображения памяти.

* Первый аргумент - желаемый адрес начала участка памяти (нам это не важно, поэтому передаем 0 и операционная система сама выберет наиболее подходящий участок);

* Второй аргумент - число байт, которое нужно отобразить в память;

* Третий аргумент - число, определяющее степень защищённости отображенного участка памяти (только чтение, только запись, исполнение, область недоступна). Значения определяются как макросы — PROT_READ, PROT_WRITE (их можно комбинировать через побитовое или);

* Четвертый аргумент описывает атрибуты области. Обычное значение — MAP_SHARED;

* Пятый аргумент - дескриптор файла, который нужно отобразить.

* Шестой аргумент - смещение отображенного участка от начала файла.

Вызов ```buffer = (char*)mmap(0, bufferSize, PROT_READ, MAP_PRIVATE, *descriptor, 0);``` производим для дескриптора, переданного в файл размера  bufferSize. Вызов вернет адрес начала участка отображаемой памяти или MAP_FAILED в случае неудачи; Здесь buffer - указатель типа **char**. Выделенная память для чтения ведет себя точно так же, как и обычная память общего назначения, то есть по ней можно просто идти циклом **for**. Далее идем по всему циклу и повторяем действия, которые были в предыдущей задаче. Единственное отличие - в предыдущей задаче мы считывали файл кусками в массив типа **char** (возможно, несколько раз, если размер файла больше размера буфера), а здесь вместо буфера служит указатель на отображенный участок памяти.

###### FindSting:
Здесь производится такая же замена на механизм отображения памяти, как и в **ReadFile**. Перед циклом **while**, в котором происходит считывание номеров строк и вывод строк по номерам, производится ```buffer = (char*)mmap(0, bufferSize, PROT_READ, MAP_PRIVATE, *descriptor, 0);``` точно так же, как и в **ReadFile**. На этом этапе мы имеем указатель на текст в файле. После этого в цикле производится поиск нужных строк. Здесь отличий почти нет: программа просит номер строки, в таблицах поиска ищет нужные значения по введенному номеру и затем идем циклом **for** по всему тексту начиная с позиции из таблицы, которая равна ```stringPositionTable[number - 1]``` и заканчивая этим значением, к которому прибавлена длина соответствующей строки, равная ```stringLengthTable[number - 1]```, т.е. мы взяли кусок из большого сегмента памяти начиная от какого-то значения из таблица отступов строк длины, которая равна соответствующему значению из таблицы длин строк. Этот кусок сохраняется в предварительно подготовленный через **malloc** массив **result** и когда цикл завершается, строка **result** выводится через **printf**. Далее **result** освобождается через **free** чтобы не было утечек памяти.

На этом отличия от предыдущей задачи заканчиваются.
