# Лабораторная работа 5: Таблица поиска строк в текстовом файле
#### Задание:
Написать программу, которая анализирует текстовый файл, созданный текстовым редактором, таким как ed(1) или vi(1). После запроса, который предлагает ввести номер строки, с использованием printf(3) программа печатает соответствующую строку текста. Ввод нулевого номера завершает работу программы. Используйте open(2), read(2), lseek(2) и close(2) для ввода/вывода. Постройте таблицу отступов в файле и длин строк для каждой строки файла. Как только эта таблица построена, позиционируйтесь на начало заданной строки и прочтите точную длину строки.

#### Ход выполнения:

###### main:
Для начала производится проверка, что программе был передан текстовый файл в качестве аргумента. В случае, если этого не происходит, программа сообщает об этом и завершается с ошибкой.

Для работы с файлами нам нужно объявить:
-  ```int descriptor;``` - переменная, хранящая дескриптор.
> Дескриптор - это неотрицательное целое число, возвращаемое системными вызовами, такими как **creat(2)**, **open(2)** или **pipe(2)**. После получения файлового дескриптора процесс может использовать его для дальнейшей работы с файлом, например с помощью системных вызовов **read(2)**, **write(2)**, **close(2)** или **fcntl(2)**.
- Массив для хранения длин строк ```int stringLengthTable[ARRAY_SIZE];```
- Массив для хранения начала каждой строки от начала файла ```intstringPositionTable[ARRAY_SIZE];```.

Далее открывается файл по переданному имени с помощью системной функции ```int open(const char *path, int oflag, /*mode_t mode*/);```
path - это имя файла, oflag указывает режим открытия файла (например, для чтения или записи, для нашего случая O_RDONLY - read only, другие можно посмотреть в man), mode содержит права доступа к файлу, если файл успешно создается. Сама системная функция возвращает целое число, которое будет дескриптором файла.

На этом этапе мы имеем файловый дескриптор, который мы передаем в функцию чтения файла ReadFile.

###### ReadFile:
В цикле с помощью ```ssize_t read(int fildes, void *buf, size_t nbyte);``` производится чтение с дескриптора, который мы передали с ранее считанного файла в буфер.
> В нашем случае буфер - это один char, то есть мы читаем по одному символу (можно было бы считать блоками побольше, но нам важно поймать  '\n', поэтому здесь придется делать много итераций цикла), nbyte указывает размер буфера (1, как я уже сказал), после завершения операции значение файлового указателя будет увеличено на количество считанных байт.

На каждой итерации цикла мы будем получать какой-то char из строки файла. Если полученный char не является '\n', такой случай нам не интересен (то есть мы всё ещё находимся на одной строке и пока не перешли на другую) и мы просто инкрементируем переменную, которая считает длину текущей строки.

Если попадётся '\n', то мы достигли конца строки и нужно:
- Ещё раз инкрементировать счетчик длины строки ('\n' такой же символ, который занимает место, как и все другие);
- Для соответствующего индекса строки выполнить ```stringLengthTable[counter] = iterator;```, то есть сохранить посчитанную длину в таблицу длин;
- Инкрементировать индекс строки;
- Используя ```off_t lseek(int fildes, off_t offset, int whence);```, получить смещение от начала файла до текущей позиции дескриптора fildes (относительно чего производится смещение и до чего задается с помощью **SEEK_SET**, **SEEK_CUR**, **SEEK_END** и других, в данном случае нас интересует смещение от самого начала файла = 0 до текущего положения, равного SEEK_CUR) и сохранить полученное смещение в таблицу отступов ```stringPositionTable[counter] = lseek(*descriptor, 0, SEEK_CUR);```;
- Обнулить счетчик длины, т.к. мы перешли на новую строку и пока что не читали её.

Эти действия будут выполняться в цикле до тех пор, пока функция **read** в условии цикла будет возвращать положительное целое число, то есть говорить о том, что мы ещё не достигли конца файла или нет ошибок. Она вернёт 0, когда читать будет нечего.

Когда мы выйдем из ReadFile, у нас будут полностью заполнены таблицы длин и отступов. Сама функция ReadFile возвращает общее количество прочитанных строк.

###### FindString
Функция имеет такую же сигнатуру, как и ReadFile и дополнительный параметр **int totalQuantityOfStrings**, который нужен для проверки введенного пользователем номера строки для распечатки на то, чтобы этот номер не превосходил максимальное количество строк в файле.

Важно заматить, что когда мы вводим в консоль какой-то номер **number**, брать из массива нужно данные с индексом **number - 1** т.к. у нас массивы индексируются с 0. Если не отнять единицу, будет браться строка с неверным индексом.

Нам потребуется буфер ```char buffer[ARRAY_SIZE];```, в который мы поместим взятую по номеру строку для вывода, в переменной ```int number;``` хранится этот номер.

Первая проверка ```if(number == 0)``` - условие выхода из программы (по заданию если вводим 0, то программа завершается).

Условие ```if(number < 0 || number > totalQuantityOfStrings)``` проверяет вхождение введенного числа в правильный промежуток строк. Для этого условия нам и нужна переменная **totalQuantityOfStrings** в сигнатуре функции.

На этом моменте мы имеем номер строки, который входит в "хороший" диапазон и нам остаётся только перейти системной функцией ```lseek(*descriptor, stringPositionTable[number - 1], SEEK_SET);```  на соответствующее смещение из таблицы смещений **stringPositionTable**.
> Я уже объяснил принцип работы **lseek** в **ReadFile**, однако здесь отличие в том, что нас интересует позиция (значение дескриптора) со смещением от начала файла до позиции, взятой из **stringPositionTable**.

Далее идет чтение по взятому только что дескриптору строки такой длины, которая равна значению, взятому из **stringLengthTable** (проще говоря, мы взяли отступ и длину строки в табличных массивах и получили нужную нам строку, соединив отступ и длину и получив соответствующий дескриптор).
> Принцип действия **read** я тоже описал в **ReadFile**, но здесь считывание строки происходит не по одному символу, а целиком, в буфер ```char buffer[ARRAY_SIZE];``` потому что нам не нужно ловить '\n', а нужно просто вывести строку в консоль.

Одновременно с чтением происходит проверка на то, что оно прошло корректно (**read** вернула положительный результат). То есть мы завернули **read** в **if** - ```if(read(*descriptor, buffer, stringLengthTable[number - 1]))``` если это условие верно, то мы выводим содержимое буфера.

Заключительный этап - с помощью системной функции ```ssize_t write(int fildes, const void *buf, size_t nbyte);```  переписываем nbyte из буфера, на который указывает  buf в файл, соответствующий дескриптору fildes. В нашем случае вместо дескриптора fildes используется **STDOUT_FILENO** - это поток стандартного вывода.

> Вообще, в UNIX системах было принято зарезервировать 0 как дескриптор стандартного ввода, 1 - стандартного вывода, 2 - потока диагностики (в него отправлялись сообщения об ошибках). Однако с приходом POSIX эти магические числа были заменены на символические константы STDIN_FILENO, STDOUT_FILENO и STDERR_FILENO соответственно.

Если указанная ранее проверка **read** ложна (то есть что-то пошло не так), то программа выведет сообщение о невозможности прочитать строку.

###### SaveTables
Это вспомогательная функция для отладки программы, в ней мы открываем на запись (создаем новый)  файл (переменная **file**) с именем **tables** в директории  и подготавливаем небольшой буфер ```char result[64] = "";``` для каждой строки, которую будем выводить в файл.

Идем циклом for по всем индексам, для каждого берем длину строки и отступ от начала файла и с помощью **sprintf** записываем построчно в файл каждую строку. ```int fprintf(FILE *restrict stream, const char *restrict format, ...);``` работает аналогично **printf**, но сохраняет свою отформатированную строку в stream (т.е. в наш маленький буфер), а не выводит её в стандартный поток вывода. Полученную строку мы записываем в **file** с помощью **fputs**

В результате в файле с именем tables для каждой строки будут лежать в читаемом виде длина строки и отступ от начала файла.


### Исправление ошибок
###### read в буфер
В функции **ReadFile**  системный вызов **read** многократно вызывался для записи в один char и дальше этот char обрабатывался. Такой способ проигрывает по скорости варианту, когда происходит одно большое считывание в **read** (в нашем случае ```bufferSize = read(*descriptor, buffer, ARRAY_SIZE)``` размер буфера равен 4096), теперь системный вызов происходит для массива char и дальше обрабатывается этот массив. Вообще, системные вызовы надо стараться использовать как можно реже, т.к. переключение из пользовательского режима в системный сильно больше по времени, чем простое исполнение кода на C.

###### Проверка на ввод
В функции **FindString** в ```scanf("%d", &number)``` была уязвимость, когда вместо числа вводилась, например, строка символов, в таком случае программа падала. Теперь это исправлено. Как нам известно, **scanf** возвращает число считанных операндов. В нашем случае, если результат этой функции не равен 1, выводится сообщение об ошибке и происходит вызов ```fflush(stdin);```, которая сбрасывает в связанный с потоком данных файл данные, находящиеся в буфере, то есть очищает stdin. После этих действий программа не падает и считывание продолжается дальше.
