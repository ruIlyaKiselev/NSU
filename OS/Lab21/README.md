# Лабораторная работа 21: Пищалка.
#### Задание:
Напишите программу, которая входит в бесконечный цикл и издает звуковой сигнал на вашем терминале каждый раз, когда вы вводите символ, на который у вас настроена посылка сигнала **SIGINT** (по умолчанию **CTRL-C**). При получении **SIGQUIT**, она должна вывести сообщение, говорящее, сколько раз прозвучал сигнал, и завершиться.

#### Ход выполнения:

###### main:
В бесконечном цикле ```while(1)``` производится обработка сигналов **SIGINT** и **SIGQUIT** с помощью вызова ```signal```.

Системный вызов ```signal(int signum, sighandler_t handler)``` устанавливает новый обработчик сигнала с номером **signum** в соответствии с параметром **handler**, который может быть функцией пользователя, **SIG_IGN** или **SIG_DFL**. При получении процессом сигнала с номером **signum** происходит следующее: если устанавливаемое значение обработчика равно **SIG_IGN**, то сигнал игнорируется; если оно равно **SIG_DFL**, то выполняются стандартные действия, связанные с сигналом. Наконец, если обработчик установлен в функцию **handler**, то сначала устанавливает значение обработчика в **SIG_DFL** или выполняется зависимая от реализации блокировка сигнала, а затем вызывается функция **handler** с параметром **signum**.
Использование функции-обработчика сигнала называется "перехватом сигнала". Сигналы **SIGKILL** и **SIGSTOP** не могут быть "перехвачены" или игнорированы. Функция **signal()** возвращает предыдущее значение обработчика сигнала или SIG_ERR при ошибке. Помимо **signal** существуют и другие родственные ей вызовы:
* ```sighold(int sig)``` - добавляет передаваемый ей сигнал в маску сигналов вызывающего процесса.
* ```sigrelse(int sig)``` - удаляет передаваемый ей сигнал из маски сигналов вызывающего процесса.
* ```sigignore(int sig)``` - устанавливает для передаваемого сигнала реакцию игнорирования.
* ```The sigpause(int sig)``` - удаляет передаваемый сигнал из маски вызывающего процесса и приостанавливает вызывающей процесс до получения сигнала.

В случае успеха ```signal()``` возвращает предыдущее положение сигнала. В противном случае возвращает SIG_ERR и оставляет пояснения в **errno**.

Для этой функции существуют две ошибки:
* **EINTR** - Сигнал был пойман во время выполнения ``sigpause()``.
* **EINVAL** - Значение аргумента sig не является допустимым сигналом или равно **SIGKILL** или **SIGSTOP**.

###### handlerSIGINT:
Это функция-обработчик для сигнала **SIGINT**, который по умолчанию вводится в терминале как **CTRL-C**. В функции на всякий случай идет проверка ```if (sig == SIGINT)``` чтобы убедиться, что ей действительно передан сигнал ей соответствующий. По условию задачи функция должна издать звук - это сделано с помощью комбинации ```printf("\a")``` и ```fflush(stdout)```, без ```fflush(stdout)``` не производится звук, это обсуждалось ранее, в других работах. После звука надо увеличить на единицу переменную-счетчик, которая будет при получении сигнала **QUIT** выводить общее число произведенных звуков.

> К сожалению, вызов **signal** не способен принимать аргументы из локальных функций. Так сложилось исторически, дело в том, что это очень древний вызов и в те древние времена были другие подходы к программированию, никто даже не подозревал, что использование глобальных переменных в будущем будет избегаться (из-за сложности программ, появления параллельного программирования, многозадачности и т.д.), однако в данной ситуации по-другому никак и приходится использовать глобальную переменную для счетчика.

###### handlerSIGQUIT:
Это функция для выхода из программы по сигналу **QUIT**. Так же как и в **handlerSIGINT** производится проверка, свой ли сигнал функция получила. Если функция получила свой сигнал, то выводится сообщение, в котором указано общее число произведенных звуков и затем программа завершается через ```exit(0)```

> Когда программа запущена, при вводе в терминал сигналов через **CTRL-C** и **CTRL-\** эти символы будут захламлять терминал, так как в атрибутах терминала я не отключал **ECHO**, я это сделал специально, чтобы видеть, что количество записей в терминале **^C** совпадает с числом, которое функция выведет при получеии **CTRL-\**. Таким образом можно убедиться, что счетчик работает правильно.
