# Лабораторная работа 4: Список строк
#### Задание:
Напишите программу, которая вставляет строки, введенные с клавиатуры, в список. Память под узлы списка выделяйте динамически с использованием malloc(3). Ввод завершается, когда в начале строки вводится точка (.). Затем все строки из списка выводятся на экран.

#### Ход выполнения:
###### В каждом элементе списка хранятся:
- Указатель на текст, считанный с клавиатуры. Сам текст выделен на куче.
- Указатель на следующий элемент списка, если он существует, иначе NULL.

###### main:
Создается головной элемент списка (указатель) и происходит инициализация (для начала всё NULL), после чего он передается в ReadText

###### ReadText:

Функция принимает вышеуказанный головной элемент и в этой функции начинается цикл, в котором происходит считывание текста с клавиатуры, происходит это до тех пор, пока не будет введен символ '.'

Текст хранится в буффере и считывается через обертку системного вызова **fgets**. Считанный текст добавляется на следующую (новую) ноду через вызов функции **NewNode**, которой в качестве аргумента передается буффер.

В этой же функции рассмотрен случай, когда в NewNode не удалось выделить память и она вернула NULL, в таком случае происходит выход из цикла.

###### NewNode:
Для начала через **malloc** выделяется память на новый узел (result), при этом происходит проверка, удалось ли выделить эту память (то есть malloc не вернул NULL).

Далее для созданного узла в поле data (это указатель на char) через malloc выделяется память в размере текста из буффера + 1 (для служебного символа \0). Здесь просходит аналогичная проверка для malloc на результат NULL.

Если указанные выше действия успешно выполнились, далее происходит копирование через **strncpy** в выделенную под строку память в узле из буффера. В качетсве последнего символа строки ставится \0 и указатель на следующий узел - NULL.

На этом этапе новый узел полностью готов и функция его возвращает.

###### PrintList:
Очевидно. Функция пробегает по списку и выводит содержимое списка через системный вызов **printf()**.

###### FreeNodes:
Начиная с первого элемента списка, функция удаляет сперва текст в узле, затем и сам узел, сделав предварительный переход на следующий узел, чтобы не поретять указатель. Удаление происходит через **free()** пока в списке есть следующий элемент.

При этом элемент head из main следует удалить в самом конце, когда список уже не нужен. Если его не удалить, будет утечка памяти.

### Про библиотечные и системные функции
###### fgets:
Функция ```char *fgets(char *str, int num, FILE *stream)``` fgets() считывает до num - 1 символов из потока stream и помещает их в буффер (массив символов), на который указывает str. Символы считываются до тех пор, пока не встретится символ «новая строка», EOF или до достижения указанного предела. По окончании считывания в массив str сразу после последнего считанного символа помещается нулевой символ.

###### strncpy:
Функция ```char *strcpy(char *str1, const char *str2)``` используется для копирования до count символов содержимого строки, на которую указывает source, в строку, на которую указывает dest. Аргумент source должен быть указателем на строку, оканчивающуюся нулевым символом. Функция strncpy() возвращает указа­тель на dest.

Если строки source и dest перекрываются, то поведение функции strncpy() не определено.

Если строка, на которую указывает source, содержит меньше чем count символов, то строка dest дополняется нулями до count символов.

С другой стороны, если строка, на которую указывает source, содержит больше чем count сим­волов, то строка dest, полученная в результате копирования, не содержит в конце завершающего нулевого символа.

###### printf:
Расположение: /usr/bin/printf

Команда ```int printf(const char *format, arg-list)``` записывает отформатированные операнды из списка arg-list  (char-ы, числа, C-style строки и т.д.) под управлением строки, на которую указывает аргумент format в стандартный поток вывода. Строка, на которую указывает format, состоит из объектов двух различных назначений. Во-первых, это символы, которые сами должны быть выведены на экран. Во-вторых, это специфика­торы формата, определяющие вид, в котором будут выведены аргументы из списка arg-list.

Если количество аргументов меньше, чем количество команд форматирования, то вывод не­определен. Если же количество аргументов больше, чем команд форматирования, то лишние ар­гументы отбрасываются.

Функция printf() возвращает количество действительно выведенных символов. Возврат отрица­тельной величины означает ошибку.

Команды форматирования могут содержать модификаторы, означающие ширину поля, точ­ность и флаг выравнивания влево. Переменная целого типа, помещенная между символом про­цент и командой форматирования, работает как спецификатор минимальной ширины поля, запол­няя поле вывода пробелами или нулями так, чтобы обеспечить указанную минимальную ширину.

По умолчанию вывод производится с выравниванием вправо. Это значит, что если ширина поля больше, чем выводимые данные, то данные будут размещены на правом краю поля. Можно задать режим выравнивания влево, вставив знак минус сразу после знака процент.

Связанные переменные среды: LANG, LC_ALL, LC_CTYPE, LC_MESSAGES, LC_NUMERIC, и NLSPATH.

###### malloc и free:
Функции ```void* malloc(std::size_t size)``` и ```void free(void* ptr)``` служат для выделения памяти общего назначения. Функция malloc() возвращает указатель на блок, запрошенный у системы, в размере как минимум запрошенного числа байт, при этом блок соответствующим образом выровнен для любого использования.

Аргументом free() является указатель на блок, ранее выделенный malloc(), calloc() или realloc(). При этом free() не нужно дополнительно передавать информацию о размере блока т.к. она уже хранится рядом с блоком в памяти (более подробно это зависит от самой реализации malloc и free) После выполнения free() это пространство становится доступным для дальнейшего распределения программой, но не возвращается в систему. Память возвращается в систему только после завершения работы программы. Если ptr является нулевым указателем, никаких действий не происходит.

После успешного завершения каждая из функций выделения памяти возвращает указатель на пространство, соответствующим образом выровненное (после возможного приведения указателя) для хранения объекта любого типа.

Если свободной памяти нет, malloc(), realloc(), calloc() и другие возвращают нулевой указатель.
Более подробную информацию можно увидеть в errno, но при этом free() не использует errno.

Функции malloc (), calloc () и realloc () завершатся ошибкой, если:

- ENOMEM - Физические ограничения системы превышены размером байтов памяти, которые не могут быть выделены.

- EAGAIN - Недостаточно памяти для выделения размера байтов памяти; но приложение может повторить попытку позже.

Важно отметить, что нельзя однозначно сказать, как работает malloc т.к. в разных операционных системах и даже в разных версиях одной операционной системы он может быть реализован по-разному. Можно даже написать и использовать свой malloc в зависимости от задачи. Однако в целом его принцип работы разобран.
