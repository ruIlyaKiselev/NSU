# Лабораторная работа 10: Код завершения команды.
#### Задание:
Напишите программу, которая запускает команду, заданную в качестве первого аргумента, в виде порожденного процесса. Все остальные аргументы программы передаются этой команде. Затем программа должна дождаться завершения порожденного процесса и распечатать его код завершения.

#### Ход выполнения:

Эта задача очень похожа на предыдущую, поэтому исходный код main.c почти такой же. Нам необходима вторая программа, её исходный код находится в minor.

##### main.c:
В начало программы был добавлен вывод числа argc и вывод аргументов программы argv, они понадобятся для отладки, в начале **minor.c** выводится то же самое. Нужно это для того, чтобы убедиться, что порожденной программе передаются все остальные аргументы из порождающей.

Далее всё как и в предыдущей программе - вызов **fork** и действия в зависимости от его значения. Отличие лишь в том, что теперь для порожденного процесса мы вызываем не утилиту **cat**, а то, что передали первым аргументом. Так как в условии задания сказано передать дочерней программе все остальные аргументы из порождающей, то вместо execl используется execv, которая передает значения как вектор (на самом деле как массив char*), при этом важно не передать нулевой и первый аргумент порождающей программы, т. к. это указано в задании. Именно поэтому вместо argv мы передаем argv + 2. Таким образом, программа получает все аргументы после первого.

Следующее отличие для блока кода родительского процесса, здесь используется макрос ```WEXITSTATUS(status)```, то есть с помощью **wait** мы получаем статус завершенного процесса, а с помощью **WEXITSTATUS** получаем восемь младших битов значения, которое вернул завершившийся дочерний процесс. Эти биты могли быть установлены в аргументе функции exit() или в аргументе оператора return функции main(). Если и другие макросы, напрмер, можно узнать, завершился ли процесс с помощью необработанного сигнала, номер завершающего сигнала, остановлен ли процесс и т.д.

Таким образом, мы имеем программу, которая выводит свои аргументы, вызывает порожденную программу с именем из argv[1] и передает ей аргументы argv[2], ... , argv[n], дожидается завершения этой программы, получает статус её завершения и извлекает 8 младших битов из возвращенного значения, после чего это число распечатывает. В том, что берётся действительно 8 бит, можно убедиться, передавая программе в качестве третьего аргумента (нулевого для порожденной) числа от 0 до 255, для чисел более 255 программа будет распечатывать остаток от деления результата на 255, то есть младшие 8 битов.

##### minor.c
Здесь всё очень просто. Как и в **main.c**, выводятся переданные аргументы, их теперь можно сравнить с аргументами программы-родителя, начиная со второго и убедиться, что всё передается верно. Далее, в случае, если был передан хотя бы один аргумент, программа выводит сообщение об успешном выполнении и переданный нулевой аргумент (третий для родительской программы), затем возвращает этот аргумент уже как число (конвертирует char* через **atoi** в int). В случае, если не было передано ни одного аргумента, программа об этом говорит и возвращает -1.
